<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>chapter4</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>chapter4</h1><br/><p>	<h2>Chapter 4 (Data Transfers, Addressing, and Arithmetic)</h2></p><p>	1.       Format for mov, movsx instructions</p><p><h2>		</h2><strong><h2>MOV </h2></strong><em><strong><h2>destination,source</h2></strong></em></p><p>		</p><p>		<img src="images/6-1.png" alt="images/6-1.png" /></p><p>		</p><p>		<img src="images/6-2.png" alt="images/6-2.png" /></p><p>		</p><p><h2>		</h2><strong><h2>MOVZX Instruction</h2></strong></p><p>		The MOVZX instruction (move with zero-extend)</p><p>		<img src="images/6-3.png" alt="images/6-3.png" /></p><p>		<img src="images/6-4.png" alt="images/6-4.png" /></p><p>		<img src="images/6-5.png" alt="images/6-5.png" /></p><p>		<img src="images/6-6.png" alt="images/6-6.png" /></p><p>		</p><p><h2>		</h2><strong><h2>The MOVSX instruction (move with sign-extend)</h2></strong></p><p>			The MOVSX instruction (move with sign-extend)</p><p>			<img src="images/6-7.png" alt="images/6-7.png" /></p><p>			<img src="images/6-8.png" alt="images/6-8.png" /></p><p>		</p><p>	 2.       Using PTR example: DWORD PTR [eax] get the dword version of eax after dereference it offset to get it value.</p><p>		valA byte 12h</p><p>		valB WORD PTR valA;</p><p>		</p><p><h2>		</h2><strong><h2>TYPE</h2></strong></p><p>		<img src="images/6-9.png" alt="images/6-9.png" /></p><p>		<strong>SIZEOF</strong> = LengthOf * TYPE</p><p>		<img src="images/6-10.png" alt="images/6-10.png" /></p><p>		</p><p>		<strong>TYPEDEF Operator</strong></p><p>		<img src="images/6-11.png" alt="images/6-11.png" /> Define our own type ( point to byte)</p><p>		</p><p>		<img src="images/6-12.png" alt="images/6-12.png" /></p><p>		</p><p>			or ptr2 BYTE PTR ArrayB</p><p>			we can access the arrayB using ESI</p><p>			mov esi, ptr2</p><p>			mov al, [esi] give 10h</p><p>		</p><p>		</p><p>		</p><p> </p><p>	3.       The SAHF instruction.</p><p>				<img src="images/6-13.png" alt="images/6-13.png" /></p><p>				<img src="images/6-14.png" alt="images/6-14.png" /></p><p>	</p><p>	4.       Give an example of how you would set the Overflow flag, Zero Flag, and Sign Flag:</p><p>			<img src="images/6-15.png" alt="images/6-15.png" /></p><p>			<strong>Overflow when convert to singed and it overflow the range, carry when convert to unsigned and it over the size : </strong></p><p>			 <strong>ex: byte can range from 0 to 255 but if we go over it, it can set the carry flag or zero</strong></p><p>			</p><p>			<strong>Also when it SBYTE range from (-128 to 127) and we go lower or higher than that, it raised the overflow flag. </strong></p><p>			</p><p>			<strong>ValA byte 255 valid , convert to signed it would be 255 – 256 = -1</strong><strong></strong></p><p><strong>			 valB sbyte 127 valid, add 1 would be -128</strong></p><p>	<strong> </strong></p><p>		<strong>Signed flag is set to 1 when a result operand go to negatives number, 0 other wise.</strong></p><p>		</p><p>	5.       Inc and dec instructions (how to use them, do they set any flags? Not the carry flag, other they will raise like AC flag, overflow flags, singed flag)</p><p>	6.       Format for the ADD and SUB instruction, NEGATE</p><p></p><p><h2>			</h2><strong><h2>Sub </h2></strong><em><strong><h2>dest, source </h2></strong></em><strong></strong></p><p><strong>			It is like destination = destination – source. EX, SUB valC, 2 = ValC – 2</strong><strong></strong></p><p><strong>			Subtract 5 from 2 = 2-5 = -3</strong><strong></strong></p><p><strong>			Subract source from destination = destination - source</strong></p><p>			</p><p><h2>			</h2><strong><h2>NEG</h2></strong> (reg or mem)</p><p>			The INC and DEC instructions do not affect the Carry flag. Applying the NEG instruction to a nonzero operand always sets the Carry flag. ( because NEG is performing bitwise, a sub operation that why it always set the carry flag) NEG = 0 - value</p><p>			<img src="images/6-16.png" alt="images/6-16.png" /></p><p>			The Overflow, Sign, Zero, Auxiliary Carry, and Parity flags are changed according to the value of the destination operand</p><p>			</p><p>			Example sumARRAY</p><p>			</p><p>			<img src="images/6-17.png" alt="images/6-17.png" /></p><p>			</p><p>			COPY a string</p><p>			<img src="images/6-18.png" alt="images/6-18.png" />			</p><p>			</p><p>	7.       The EIP register: what is it, how is it used.</p><p><strong>	EIP is a register in x86 architectures (32bit). It holds the &quot;Extended Instruction Pointer&quot; for the stack. In other words, it tells the computer where to go next to execute the next command and controls the flow of a program</strong></p><p>	<h3>9. JMP and LOOP</h3></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p></div>
</body>
</html>
