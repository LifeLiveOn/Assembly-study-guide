<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>chapter5</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>chapter5</h1><br/><p><strong>Chapter 5 (Procedures)</strong><strong></strong></p><p><strong></strong></p><p>	<strong>1. How does the stack work â€“last in first out.</strong><strong></strong></p><p><strong></strong><strong></strong></p><p><strong>	2. What is the difference between the runtime stack the stack abstract data type (ADT).</strong><strong></strong></p><p><strong></strong><strong><h2>		Runtime Stack (32-Bit Mode)</h2></strong><strong></strong></p><p><strong>		</strong><strong></strong></p><p><strong>			</strong>The runtime stack is a memory array managed directly by the CPU, used to keep track of subroutine return addresses, procedure parameters, local variables, and other subroutine-related data. </p><p>			In 32-bit mode, the ESP register (known as the stack pointer) holds a 32-bit offset into some location on the stack. </p><p>			We rarely manipulate ESP 	directly; instead, it is indirectly modified by instructions such as CALL, RET, PUSH, and POP.<strong></strong></p><p><strong>			</strong><img src="images/7-1.png" alt="images/7-1.png" /><img src="images/7-2.png" alt="images/7-2.png" /></p><p>			</p><p>			</p><p>		PUSH OPERATION </p><p>		DECREMENT the ESP ( stack pointer) by 4 hex ( 32 bit)</p><p>		</p><p>		<strong>POP OPERATION.</strong></p><p>		return a copy of the value in the stack where ESP pointing too and increment ESP by 4</p><p>		<img src="images/7-3.png" alt="images/7-3.png" /></p><p>		</p><p><h1>		</h1><strong><h1>EBP</h1></strong> (frame pointer) point to the data on the stack</p><p>		<img src="images/7-4.png" alt="images/7-4.png" /></p><p>		 		<strong></strong></p><p><strong>	</strong><strong></strong></p><p><strong>	5. The PUSHAD instruction</strong><strong></strong></p><p><strong>		</strong>The PUSHFD instruction pushes the 32-bit EFLAGS register on the stack, and POPFD pops the stack into EFLAGS:</p><p>		</p><p>		<img src="images/7-5.png" alt="images/7-5.png" /></p><p><h3>		</h3><strong><h3>The PUSHAD instruction</h3></strong><h3> </h3></p><p>		pushes all of the 32-bit general-purpose registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP (value before executing PUSHAD), EBP, ESI, and EDI. The POPAD instruction pops the same registers off the stack in reverse order.</p><p>		</p><p>		<strong>PUSHA instruction</strong>, pushes the 16-bit general-purpose registers (AX, CX, DX, BX, SP, BP, SI, DI) on the stack in the order listed. The POPA instruction pops the same registers in reverse.<strong></strong></p><p><strong>			</strong><strong></strong></p><p><strong>	</strong><strong></strong></p><p><strong>	6. What is the scope of a label within a procedure</strong><strong></strong></p><p><strong>		</strong>they are local variable which mean if you define a jmp outside of the procedure, you can&#39;t jump to it unless it is a global Label<strong></strong></p><p><strong>	7. The RET instruction</strong><strong></strong></p><p><strong>		</strong>RET forces the CPU to return to the location from where the procedure was called</p><p>		ex:</p><p>			call WriteString</p><p>			do sth here. - &lt; return sent the EIP to here to execute next instruction after the call</p><p>			WriteString PROC</p><p>			...</p><p>			WriteString ENDP</p><p>	<img src="images/7-6.png" alt="images/7-6.png" />		</p><p>	<strong></strong></p><p><strong>	8. A nested procedure call</strong><strong></strong></p><p><strong>			</strong><img src="images/7-7.png" alt="images/7-7.png" /></p><p>		</p><p>	10. The USES operator, coupled with the PROC directive</p><p>		<img src="images/7-8.png" alt="images/7-8.png" /><img src="images/7-9.png" alt="images/7-9.png" /></p><p>		</p><p>		follow the order in uses from left to right for push and pop if not used with use<strong></strong></p><p><strong>	</strong></p><p><h2>		</h2><strong><h2>Irvine</h2></strong><h2> </h2><strong><h2>library</h2></strong></p><p>		</p><p>		Clrscr ( clear the console window)</p><p>		CRLF ( next line) </p><p>		DumpRegs ( show register)</p><p>		<strong>RandomRange ( random integer with the range of 0 to n-1  depend on eax value), the random integer is returned in EAX</strong></p><p>		</p><p>		<img src="images/7-10.png" alt="images/7-10.png" /> in range from 0 - 4999 and place it in randVal</p><p>		Randomrange generate a random value base on 0 to eax value</p><p>		<img src="images/7-11.png" alt="images/7-11.png" />		ex from -50 to 49</p><p>		</p><p>		</p><p>		</p><p>		WriteChar ( use al)</p><p>		</p><p>		writeDec (use eax) for decimal</p><p>		</p><p>		writeHex( use eax) for hex but it will display like the full 32 bit hex value; example mov eax, 7Fh -&gt; display &quot;0000007F&quot;</p><p>		</p><p>		writeHExB (use eax for value, EBX  type format )</p><p>		</p><p>		<img src="images/7-12.png" alt="images/7-12.png" /></p><p>		</p><p>		WriteInt ( eax) for signed 32 bit integer</p><p>		<img src="images/7-13.png" alt="images/7-13.png" /></p><p>		</p><p>		writeString ( use offset of edx)</p><p>		<img src="images/7-14.png" alt="images/7-14.png" />		</p><p>		</p></div>
</body>
</html>
